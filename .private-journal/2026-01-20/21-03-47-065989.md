---
title: "9:03:47 PM - January 20, 2026"
date: 2026-01-20T20:03:47.065Z
timestamp: 1768939427065
---

## Project Notes

Fixed ResizableTextEdit border and resize issues - proper implementation:

Original broken approach:
- Just drew border in paint() - no actual clickable space
- Tried to override boundingRect() but text_edit still filled proxy widget
- Mouse events inside text_edit went directly to text_edit, bypassing proxy
- Resizing text_edit didn't update proxy widget's bounding rect

Correct implementation:
1. Container widget approach:
   - Create QWidget container with gray background (RGB 180,180,180)
   - Use QVBoxLayout with margins equal to border width (3px)
   - Add text_edit to layout - margins create actual border space
   - Set container as proxy widget (not text_edit directly)
   
2. Benefits:
   - Border area is real widget space, not just painted
   - Clicks on border area go to container/proxy, not text_edit
   - Clicks inside text_edit area still work for text editing
   - Natural selection behavior without custom mouse event handling

3. Resize fix:
   - Store container dimensions in resize_start_size, not text_edit
   - Resize container.setFixedSize(), not text_edit
   - prepareGeometryChange() before resize to update bounding rect
   - Layout automatically adjusts text_edit size based on container - margins

4. Serialization:
   - Save text_edit dimensions (content area, no borders)
   - Load by passing size to __init__
   - __init__ adds 2*border_width to create container size
   - Layout margins ensure text_edit gets correct size

Key lesson: With QGraphicsProxyWidget containing interactive widgets, you need actual widget hierarchy to create clickable areas. Can't just paint and override geometry methods.

## Technical Insights

QGraphicsProxyWidget interaction model:
- When proxy contains interactive widget (QTextEdit, QLineEdit, etc.), mouse events inside widget go directly to the widget
- Proxy's mouse event handlers only get events outside the embedded widget's geometry
- To create clickable border/frame area, need widget hierarchy with actual margin space
- Can't fake it with just painting and boundingRect overrides

Proper pattern for bordered interactive proxy widgets:
1. Container QWidget with styling for border/background
2. Layout with margins to create border space
3. Interactive widget (QTextEdit etc) in layout
4. Set container as proxy widget
5. Border area naturally intercepts clicks for selection/movement

prepareGeometryChange() is critical:
- Must call before changing item's bounding rect
- Tells QGraphicsScene to invalidate cached rects
- Without it, scene doesn't know geometry changed, leading to visual bugs like stale handle positions
